\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Author: PyCPBook Community}
\PYG{l+s+sd}{Source: Based on common implementations in competitive programming resources}
\PYG{l+s+sd}{Description: Implements the Union\PYGZhy{}Find data structure, also known as}
\PYG{l+s+sd}{Disjoint Set Union (DSU). It is used to keep track of a partition of a set}
\PYG{l+s+sd}{of elements into a number of disjoint, non\PYGZhy{}overlapping subsets. The two primary}
\PYG{l+s+sd}{operations are finding the representative (or root) of a set and merging two sets.}

\PYG{l+s+sd}{This implementation includes two key optimizations:}
\PYG{l+s+sd}{1.  Path Compression: During a `find` operation, it makes every node on the}
\PYG{l+s+sd}{    path from the query node to the root point directly to the root. This}
\PYG{l+s+sd}{    dramatically flattens the tree structure.}
\PYG{l+s+sd}{2.  Union by Size: During a `union` operation, it always attaches the root of}
\PYG{l+s+sd}{    the smaller tree to the root of the larger tree. This helps in keeping}
\PYG{l+s+sd}{    the trees shallow, which speeds up future `find` operations.}

\PYG{l+s+sd}{The combination of these two techniques makes the amortized time complexity}
\PYG{l+s+sd}{of both `find` and `union` operations nearly constant.}
\PYG{l+s+sd}{Time: \PYGZdl{}O(\PYGZbs{}\PYGZbs{}alpha(N))\PYGZdl{} on average for both find and union operations, where \PYGZdl{}\PYGZbs{}\PYGZbs{}alpha\PYGZdl{}}
\PYG{l+s+sd}{is the extremely slow\PYGZhy{}growing inverse Ackermann function. For all practical}
\PYG{l+s+sd}{purposes, this is considered constant time.}
\PYG{l+s+sd}{Space: \PYGZdl{}O(N)\PYGZdl{} to store the parent and size arrays for N elements.}
\PYG{l+s+sd}{Status: Stress\PYGZhy{}tested}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}


\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{UnionFind}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    A class that implements the Union\PYGZhy{}Find data structure with path compression}
\PYG{l+s+sd}{    and union by size optimizations.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Initializes the Union\PYGZhy{}Find structure for n elements, where each element}
\PYG{l+s+sd}{        is initially in its own set.}
\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            n (int): The number of elements.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parent} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{size} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{n}{n}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{find}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Finds the representative (root) of the set containing element i.}
\PYG{l+s+sd}{        Applies path compression along the way.}
\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            i (int): The element to find.}
\PYG{l+s+sd}{        Returns:}
\PYG{l+s+sd}{            int: The representative of the set containing i.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parent}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{==} \PYG{n}{i}\PYG{p}{:}
            \PYG{k}{return} \PYG{n}{i}
        \PYG{c+c1}{\PYGZsh{} Path compression: set the parent directly to the root.}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parent}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parent}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parent}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

    \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{union}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Merges the sets containing elements i and j.}
\PYG{l+s+sd}{        Applies union by size.}
\PYG{l+s+sd}{        Args:}
\PYG{l+s+sd}{            i (int): An element in the first set.}
\PYG{l+s+sd}{            j (int): An element in the second set.}
\PYG{l+s+sd}{        Returns:}
\PYG{l+s+sd}{            bool: True if the sets were merged, False if they were already in the same set.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{root\PYGZus{}i} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{root\PYGZus{}j} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{root\PYGZus{}i} \PYG{o}{!=} \PYG{n}{root\PYGZus{}j}\PYG{p}{:}
            \PYG{c+c1}{\PYGZsh{} Union by size: attach the smaller tree to the root of the larger tree.}
            \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{size}\PYG{p}{[}\PYG{n}{root\PYGZus{}i}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{size}\PYG{p}{[}\PYG{n}{root\PYGZus{}j}\PYG{p}{]}\PYG{p}{:}
                \PYG{n}{root\PYGZus{}i}\PYG{p}{,} \PYG{n}{root\PYGZus{}j} \PYG{o}{=} \PYG{n}{root\PYGZus{}j}\PYG{p}{,} \PYG{n}{root\PYGZus{}i}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parent}\PYG{p}{[}\PYG{n}{root\PYGZus{}j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{root\PYGZus{}i}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{size}\PYG{p}{[}\PYG{n}{root\PYGZus{}i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{size}\PYG{p}{[}\PYG{n}{root\PYGZus{}j}\PYG{p}{]}
            \PYG{k}{return} \PYG{k+kc}{True}
        \PYG{k}{return} \PYG{k+kc}{False}

\end{MintedVerbatim}
