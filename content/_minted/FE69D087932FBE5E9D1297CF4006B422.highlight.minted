\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Author: PyCPBook Community}
\PYG{l+s+sd}{Source: Collective experience from competitive programmers.}
\PYG{l+s+sd}{Description: This section outlines common debugging techniques and tricks}
\PYG{l+s+sd}{useful in a competitive programming context. Since standard debuggers are}
\PYG{l+s+sd}{often unavailable or too slow on online judges, these methods are invaluable.}

\PYG{l+s+sd}{1. Debug Printing to stderr:}
\PYG{l+s+sd}{   \PYGZhy{} The most common technique is to print variable states at different points}
\PYG{l+s+sd}{     in the code.}
\PYG{l+s+sd}{   \PYGZhy{} Always print to standard error (`sys.stderr`) instead of standard output}
\PYG{l+s+sd}{     (`sys.stdout`). The online judge ignores `stderr`, so your debug messages}
\PYG{l+s+sd}{     won\PYGZsq{}t interfere with the actual output and cause a \PYGZdq{}Wrong Answer\PYGZdq{} verdict.}
\PYG{l+s+sd}{   \PYGZhy{} Example: `print(f\PYGZdq{}DEBUG: Current value of x is \PYGZob{}x\PYGZcb{}\PYGZdq{}, file=sys.stderr)`}

\PYG{l+s+sd}{2. Test with Edge Cases:}
\PYG{l+s+sd}{   \PYGZhy{} Before submitting, always test your code with edge cases.}
\PYG{l+s+sd}{   \PYGZhy{} Minimum constraints: e.g., N=0, N=1, empty list.}
\PYG{l+s+sd}{   \PYGZhy{} Maximum constraints: e.g., N=10\PYGZca{}5. (Check for TLE \PYGZhy{} Time Limit Exceeded).}
\PYG{l+s+sd}{   \PYGZhy{} Special values: e.g., zeros, negative numbers, duplicates.}
\PYG{l+s+sd}{   \PYGZhy{} A single off\PYGZhy{}by\PYGZhy{}one error can often be caught by testing N=1 or N=2.}

\PYG{l+s+sd}{3. Assertions:}
\PYG{l+s+sd}{   \PYGZhy{} Use `assert` to check for invariants in your code. An invariant is a}
\PYG{l+s+sd}{     condition that should always be true at a certain point.}
\PYG{l+s+sd}{   \PYGZhy{} For example, if a variable `idx` should always be non\PYGZhy{}negative, you}
\PYG{l+s+sd}{     can add `assert idx \PYGZgt{}= 0`.}
\PYG{l+s+sd}{   \PYGZhy{} If the assertion fails, your program will crash with an `AssertionError`,}
\PYG{l+s+sd}{     immediately showing you where the logic went wrong.}
\PYG{l+s+sd}{   \PYGZhy{} Assertions are automatically disabled in Python\PYGZsq{}s optimized mode (`python \PYGZhy{}O`),}
\PYG{l+s+sd}{     so they have no performance penalty on the judge if it runs in that mode.}

\PYG{l+s+sd}{4. Naive Solution Comparison:}
\PYG{l+s+sd}{   \PYGZhy{} If you have a complex, optimized algorithm, write a simple, brute\PYGZhy{}force}
\PYG{l+s+sd}{     (naive) solution that is obviously correct but slow.}
\PYG{l+s+sd}{   \PYGZhy{} Generate a large number of small, random test cases.}
\PYG{l+s+sd}{   \PYGZhy{} Run both your optimized solution and the naive solution on each test case}
\PYG{l+s+sd}{     and assert that their outputs are identical.}
\PYG{l+s+sd}{   \PYGZhy{} If they differ, print the failing test case. This is the core idea behind}
\PYG{l+s+sd}{     the stress tests used in this project.}

\PYG{l+s+sd}{5. Rubber Duck Debugging:}
\PYG{l+s+sd}{   \PYGZhy{} Explain your code, line by line, to someone else or even an inanimate}
\PYG{l+s+sd}{     object (like a rubber duck).}
\PYG{l+s+sd}{   \PYGZhy{} The act of verbalizing your logic often helps you spot the flaw yourself.}
\PYG{l+s+sd}{Time: N/A}
\PYG{l+s+sd}{Space: N/A}
\PYG{l+s+sd}{Status: Not applicable (Informational)}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{sys}


\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{example\PYGZus{}debug\PYGZus{}print}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    A simple example demonstrating how to print debug information}
\PYG{l+s+sd}{    to stderr without affecting the program\PYGZsq{}s actual output.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} This is the actual output that the judge will see.}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Processing started.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} This is a debug message. It goes to stderr and is ignored by the judge.}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DEBUG: Processing item }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ with value }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{item}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{file}\PYG{o}{=}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{stderr}\PYG{p}{)}
        \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{item}

    \PYG{c+c1}{\PYGZsh{} This is the final output.}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The final total is: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{total}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\end{MintedVerbatim}
